# 图形学项目报告
16337269 颜彬
## 构建方法
（本项目已包含可执行文件，此步骤可以跳过）
``` sh
# 在文件夹根目录下
$ make
```
## 运行方法
在根目录下
``` sh
$ make run
```
## 运行结果
![](star.png)
## 项目亮点
###　渐变效果
实现了星球随着时间变化时，从亮到暗、再从暗到亮的不断变化的效果
### 自动运行模式
运行文件后，按下`R`后进入自动运行模式，小球会自动自转并绕着大球公转。
按下`Shift+R`关闭自动运行。关闭后用户可以使用`D`, `Shift+D`, `Y`, `Shift+Y`自由地操控小球。
## 文件介绍
### 根目录文件介绍
```
.
├── 16337269_颜彬_实验报告.html
├── 16337269_颜彬_实验报告.md
├── 16337269_颜彬_实验报告.pdf
├── common/
├── distrib/
├── external/
├── Makefile
├── star/
└── star.png

4 directories, 5 files
```
- 16337269_颜彬_实验报告.pdf
项目实验报告
- common/
放置各个程序都可能需要的共同的代码。例如跟着色器有关的辅助代码
- external/
外部库，存放例如`glew`, `glfw`, `glm`等库。
- star/
项目源码。存放画出星球的代码。
- Makefile
构筑整个项目的Makefile 文件
- star.png
项目截图
### 源码目录文件介绍
```
.
├── include/
│   ├── config.hpp
│   ├── Makefile
│   ├── mymath.cpp
│   └── mymath.hpp
├── Makefile
├── SimpleFragmentShader.fragmentshader
├── SimpleVertexShader.vertexshader
├── star.cpp
└── star.out
```
- include
存放自己编写的项目中需要的代码
    - mymath.cpp mymath.hpp
    存放数学辅助函数。包括画出圆的经线和纬线等。
    - config.hpp
    定义一些配置全局变量。例如圆的经线有多少，纬线有多少，程序的运行速度等。
- star.cpp
程序主体和入口
- star.out
可执行文件
- SimpleVertexShader.vertexshader
vertex着色器
- SimpleFragmentShader.fragmentshader
fragment着色器
## 项目细节
与上个实验相比，本次实验增加的地方有以下几个方面
- 按键响应
通过按键回调函数修改全局变量的方式和程序其他部分交互
- 球的框线
使用基本解析几何的方式，用圆的参数方程分别画出纬线和经线
- 立体效果
采用Model, View, Projection矩阵的变换来实现
### 按键响应
定义了回调函数
``` C++
static void key_call_back(GLFwindow* window, 
    int key ,
    int scanCode, 
    int action, 
    int mod)；
```
在回调函数中判断拿下的键是否是`Y`, `Shift+Y`, `D`, `Shift+D`, `R`, `Shift+R`.
其中不按下`shift`时，`mod`为0， 按下`shift`时`mod`为1.通过检测`mod`可以知道`shift`是否有按下。

当按下时，`action = 1`,松开时，`action = 0`, 当持续按下时，`action = 2`。

回调函数会修改若干个全局变量，记录着小球的自转角度和公转角度。在程序的其他部分，这些全局变量用来产生矩阵，进而产生进一步的视觉效果。

### 球的框线
在本实现中，以`Z`轴为球轴，以`XOY`平面为切面，切除的大圆作为球的纬线。

为画出纬线，首先要求出大圆的半径$$r = \sqrt{R^2 - d^2}$$
其中R为球的半径，d为截面距离球心的距离。其中在本坐标系中，有$$d = z_0$$
即距离恰好为截面的z轴截距。
当确定好这些参数后，可以知道$z = z_0$截面截出的大圆的方程为
$$
\begin{aligned}
x &= r\cos\theta \\
y &= r\sin\theta \\
z &= z_0
\end{aligned}
$$


为了画出球的经线，需要用球的参数方程。
$$
\begin{aligned}
x &= R\cos\theta\cos\phi \\
y &= R\sin\theta\cos\phi \\
z &= R\sin\phi
\end{aligned}
$$
其中R是定值。

通过基础的解析几何知识可知，一条经线由两束曲线构成。
当固定$\theta = \theta_0$，$\phi$从0变化到$\pi$时，是经线的一半。
取$\theta = \theta_0 + \pi$，$\phi$从$\pi$变化到$2\pi$时，是经线的另一半。

有了这些结论，就可以画出球的若干个经线和纬线。

### 立体效果
对于小球来说。其需要平移到世界坐标系的某个位置。其需要作伸缩变换（小球和大球在模型坐标系下是一模一样的，只是在变换到世界坐标系时需要作缩小）。其还需要作旋转变换（小球可以自转)
由此可知Model变化矩阵的表达式应与下列代码相似。
``` C++
glm::mat4 Rotate = 
    glm::rotate(Identity, float(spin_rotate), glm::vec3(0, 1, 0));
glm::mat4 Scale = 
    glm::scale(Identity, glm::vec3(0.5, 0.5, 0.5));
glm::mat4 Translation = 
    glm::translate(Identity, glm::vec3(3, 0, 0));
glm::mat4 Revolution = 
    glm::rotate(Identity, float(revolution_rotate), glm::vec3(0, 1, 0));
glm::mat4 Model = 
    Revolution * Translation * Scale * Rotate;
```
Rotate矩阵将小球绕y轴自转`spin_rotate`角度。Scale矩阵将小球等比缩放为原来的一半。Translate矩阵将小球平移到世界坐标系的(3, 0, 0)位置。Revolution矩阵作用于平移后的小球，使其公转。

最后的Model矩阵为这些矩阵的乘积。

Projection矩阵和View矩阵与前一个项目一致。不再赘述。
``` C++
glm::mat4 Projection = glm::perspective(
    glm::radians(45.0f), 
    float(16)/9, 
    0.1f, 
    100.0f);
glm::mat4 View = glm::lookAt(
    glm::vec3(0, 0, 8),
    glm::vec3(0, 0, 0),
    glm::vec3(0, 1, 0)
);
glm::mat4 Identity = glm::mat4(1.0f);
```

最后的`mvp`矩阵表示为Project, View, Model矩阵的乘积。需要留意矩阵乘法是右结合的。

`glGetUniformLocation`和`lgUniforMatrix4fv`用于向着色器写入矩阵。
```C++
glm::mat4 mvp = Projection * View * Model;

GLuint MVP_ID = glGetUniformLocation(programID, "MVP");
glUniformMatrix4fv(MVP_ID, 1, GL_FALSE, &mvp[0][0]);
```

